#include <esp_now.h>
#include <WiFi.h>
#include <FastLED.h>
#include <math.h>

#define LED_PIN     32
#define NUM_LEDS    64
#define BRIGHTNESS  64
#define LED_TYPE    WS2812B
#define COLOR_ORDER GRB

// ========== TIMING CONSTANTS (adjust these to find best fit) ==========
#define UPDATE_INTERVAL      100      // How often to update matrix (ms)
#define TIMEOUT              3000     // Time without data before turning off (ms)
#define TIME_TO_FULL         10000    // Time for red center to reach full brightness (ms)
#define FLASH_PERIOD         500      // Flash period when full brightness reached (ms)
#define ENERGY_THRESHOLD     10       // Energy level below this triggers red timer

// Ring multipliers for energy mapping
#define OUTER_MULTIPLIER     1.8f     // Green ring brightness multiplier
#define INNER_MULTIPLIER     1.8f     // Blue ring brightness multiplier
// =======================================================================

CRGB leds[NUM_LEDS];

// Outer ring (green for stationary energy) — 28 LEDs
const uint8_t outerRing[] = {
  0, 1, 2, 3, 4, 5, 6, 7,
  8, 23, 24, 39, 40, 55,
  56, 57, 58, 59, 60, 61, 62, 63,
  48, 47, 32, 31, 16, 15
};

// Inner ring (blue for moving energy) — 20 LEDs
const uint8_t innerRing[] = {
  14, 13, 12, 11, 10, 9,
  22, 25, 38, 41, 54,
  53, 52, 51, 50, 49,
  46, 33, 30, 17
};

// Center ring (red for elapsed time) — 16 LEDs
const uint8_t centerRing[] = {
  18, 19, 20, 21,
  26, 27, 28, 29,
  34, 35, 36, 37,
  42, 43, 44, 45
};

#pragma pack(push, 1)
typedef struct {
  uint16_t stationaryEnergy;
  uint16_t movingEnergy;
  uint32_t ts_ms;
} SensorData;
#pragma pack(pop)

SensorData incomingData;
uint32_t packetCount = 0;
unsigned long lastUpdate = 0;
unsigned long lastEnergyTime = 0;

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  FastLED.setBrightness(BRIGHTNESS);
  FastLED.clear();
  FastLED.show();
  
  WiFi.mode(WIFI_STA);
  Serial.print("Receiver MAC: ");
  Serial.println(WiFi.macAddress());
  
  if (esp_now_init() != ESP_OK) {
    Serial.println("ESP-NOW init failed");
    return;
  }
  esp_now_register_recv_cb(OnDataRecv);
  Serial.println("Receiver Ready. Waiting for sensor data...");
  
  lastEnergyTime = millis();
}

void updateMatrix() {
  if (millis() - lastUpdate > TIMEOUT) {
    FastLED.clear();
    FastLED.show();
    return;
  }
  
  FastLED.clear();
  
  int outerLit = constrain((int)(sqrtf(incomingData.stationaryEnergy) * OUTER_MULTIPLIER), 0, sizeof(outerRing) / sizeof(outerRing[0]));
  int innerLit = constrain((int)(sqrtf(incomingData.movingEnergy + 1) * INNER_MULTIPLIER), 0, sizeof(innerRing) / sizeof(innerRing[0]));
  
  for (int i = 0; i < outerLit; i++) {
    leds[outerRing[i]] = CRGB(0, 64, 0);
  }
  
  for (int i = 0; i < innerLit; i++) {
    leds[innerRing[i]] = CRGB(0, 0, 64);
  }
  
  if (incomingData.stationaryEnergy < ENERGY_THRESHOLD && incomingData.movingEnergy < ENERGY_THRESHOLD) {
    unsigned long timeSinceEnergy = millis() - lastEnergyTime;
    
    if (timeSinceEnergy < TIME_TO_FULL) {
      uint8_t brightness = (timeSinceEnergy * 255) / TIME_TO_FULL;
      CRGB centerColor = CRGB(brightness, 0, 0);
      
      for (int i = 0; i < sizeof(centerRing) / sizeof(centerRing[0]); i++) {
        leds[centerRing[i]] = centerColor;
      }
    } else {
      uint8_t flashBrightness = (millis() % FLASH_PERIOD) < (FLASH_PERIOD / 2) ? 255 : 64;
      CRGB centerColor = CRGB(flashBrightness, 0, 0);
      
      for (int i = 0; i < sizeof(centerRing) / sizeof(centerRing[0]); i++) {
        leds[centerRing[i]] = centerColor;
      }
    }
  }
  
  FastLED.show();
}

void loop() {
  if (millis() - lastUpdate >= UPDATE_INTERVAL) {
    lastUpdate = millis();
    updateMatrix();
  }
}

#if defined(ESP_IDF_VERSION_MAJOR) && ESP_IDF_VERSION_MAJOR >= 5
void OnDataRecv(const esp_now_recv_info_t *recv_info, const uint8_t *data, int len) {
#else
void OnDataRecv(const uint8_t *mac_addr, const uint8_t *data, int len) {
#endif
  if (len == sizeof(SensorData)) {
    memcpy(&incomingData, data, sizeof(SensorData));
    packetCount++;
    lastUpdate = millis();
    
    if (incomingData.movingEnergy > ENERGY_THRESHOLD || incomingData.stationaryEnergy > ENERGY_THRESHOLD) {
      lastEnergyTime = millis();
    }
    
    Serial.printf("[%lu] Static: %d, Moving: %d\n",
                  packetCount,
                  incomingData.stationaryEnergy,
                  incomingData.movingEnergy);
  } else {
    Serial.println("Invalid packet size");
  }
}
