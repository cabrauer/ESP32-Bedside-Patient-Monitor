#include <esp_now.h>
#include <WiFi.h>
#include <FastLED.h>
#include <math.h>

#define LED_PIN     32
#define NUM_LEDS    64
#define BRIGHTNESS  64
#define LED_TYPE    WS2812B
#define COLOR_ORDER GRB

CRGB leds[NUM_LEDS];

// Outer ring (green for moving energy) — 28 LEDs
const uint8_t outerRing[] = {
  0, 1, 2, 3, 4, 5, 6, 7,
  8, 23, 24, 39, 40, 55,
  56, 57, 58, 59, 60, 61, 62, 63,
  48, 47, 32, 31, 16, 15
};

// Inner ring (blue for stationary energy) — 20 LEDs
const uint8_t innerRing[] = {
  14, 13, 12, 11, 10, 9,
  22, 25, 38, 41, 54,
  53, 52, 51, 50, 49,
  46, 33, 30, 17
};

#pragma pack(push, 1)
typedef struct {
  uint16_t stationaryEnergy;
  uint16_t movingEnergy;
  uint32_t ts_ms;
} SensorData;
#pragma pack(pop)

SensorData incomingData;
uint32_t packetCount = 0;
unsigned long lastUpdate = 0;
const int updateInterval = 100;
const unsigned long timeout = 3000;

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  // FastLED setup
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  FastLED.setBrightness(BRIGHTNESS);
  FastLED.clear();
  FastLED.show();
  
  // ESP-NOW setup
  WiFi.mode(WIFI_STA);
  Serial.print("Receiver MAC: ");
  Serial.println(WiFi.macAddress());
  
  if (esp_now_init() != ESP_OK) {
    Serial.println("ESP-NOW init failed");
    return;
  }
  esp_now_register_recv_cb(OnDataRecv);
  Serial.println("Receiver Ready. Waiting for sensor data...");
}

void updateMatrix() {
  // Check timeout
  if (millis() - lastUpdate > timeout) {
    FastLED.clear();
    FastLED.show();
    return;
  }
  
  FastLED.clear();
  
  // Map energy values using square root
  int outerLit = constrain((int)(sqrtf(incomingData.movingEnergy) * 0.886f), 0, sizeof(outerRing) / sizeof(outerRing[0]));
  int innerLit = constrain((int)(sqrtf(incomingData.stationaryEnergy) * 0.632f), 0, sizeof(innerRing) / sizeof(innerRing[0]));
  
  // Light outer ring (green for moving)
  for (int i = 0; i < outerLit; i++) {
    leds[outerRing[i]] = CRGB(0, 64, 0);
  }
  
  // Light inner ring (blue for stationary)
  for (int i = 0; i < innerLit; i++) {
    leds[innerRing[i]] = CRGB(0, 0, 64);
  }
  
  FastLED.show();
}

void loop() {
  if (millis() - lastUpdate >= updateInterval) {
    lastUpdate = millis();
    updateMatrix();
  }
}

#if defined(ESP_IDF_VERSION_MAJOR) && ESP_IDF_VERSION_MAJOR >= 5
void OnDataRecv(const esp_now_recv_info_t *recv_info, const uint8_t *data, int len) {
#else
void OnDataRecv(const uint8_t *mac_addr, const uint8_t *data, int len) {
#endif
  if (len == sizeof(SensorData)) {
    memcpy(&incomingData, data, sizeof(SensorData));
    packetCount++;
    lastUpdate = millis();
    
    Serial.printf("[%lu] Static: %d, Moving: %d\n",
                  packetCount,
                  incomingData.stationaryEnergy,
                  incomingData.movingEnergy);
  } else {
    Serial.println("Invalid packet size");
  }
}
